# Proposed Project Directory Structure

The `btcmesh` project will be organized within the `lora/` directory as follows:

```
lora/
└── btcmesh/
    ├── btcmesh_cli.py         # Client script for sending transactions
    ├── btcmesh_server.py      # Server/Relay script for processing transactions
    ├── core/                  # Core logic for the server/relay
    │   ├── __init__.py
    │   ├── config_loader.py   # For loading config.ini
    │   ├── logger_setup.py    # For setting up consistent logging
    │   ├── transaction_parser.py # For decoding raw Bitcoin transactions
    │   ├── rpc_client.py      # For interacting with Bitcoin RPC
    │   └── reassembler.py     # For reassembling chunked messages
    ├── project/               # Project planning documents (this file, reference_materials.md)
    │   ├── tasks.txt
    │   └── reference_materials.md
    ├── logs/                  # Directory for log files (created at runtime)
    │   └── btcmesh_server.log
    │   └── btcmesh_cli.log    # If btcmesh_cli.py also implements file logging
    ├── tests/                 # Unit and integration tests
    │   ├── __init__.py
    │   ├── test_config_loader.py
    │   ├── test_transaction_parser.py
    │   ├── test_rpc_client.py
    │   ├── test_reassembler.py
    │   ├── test_btcmesh_cli.py
    │   └── test_btcmesh_server.py
    ├── config.ini.example     # Example configuration file for the server
    └── README.md              # Project README describing setup, usage, etc.
```

# Raw Transaction example
02000000000108bf2c7da5efaf2708170ffbafde7b2b0ca68234474ea71d443aee6aebfbf998030000000000fdffffffd6fcdbf37f974be27e8b0d66638355e5f53bfaf7b930fae035d23b313c4751042900000000fdffffffcccc5ca913b8eb426fd7c6bb578eab0f26583d40c51ce52cb12a428c1e75f7320100000000fdffffff981b8b54ad2a8bd8b59d063e9473aead87412b699cb969298cf29b8787fe10600000000000fdffffff5d154c445b35a92aaf179c078cdab6310e69455cde650f128cbe85d92bab51600100000000fdffffff7d23c74a412ef33d5dd856d01933dd6a5453aee3539b12349febbf6c1ba157980100000000fdffffffc5c95ce2eac84fbd3db87bbbdb4cc0855088e891cc57b1f9e0684943a399aabf0000000000fdffffffb7ef5d8a55141068da0d7b5a712ad9bbe44c3b8b412d0df5b9bcad366d71c8f90500000000fdffffff01697c63030000000016001482ea8436a6318c989767a51ce33886d65faf59a10247304402203ec9cfb2b60a7b1df545493d1794fec0b8b6d8589f562f61c9aec6852775b54102205dfb34dcc9cc31110fdf4e4544c76e9a664cf29e8f1f9905771db386882527190121030e92cc6f0829ea8b91469c8aa7ca0660d66020d3e8baaece478905e0c30c1f770247304402204a3a6a7a5d4ff285b1ba4a3457dae8566a1616738f94e9eddcce6a75dbb831ef0220285c586f6463dcf68ccef59484b2d12bccd7d68a68b7092068e6cbfd96f04d88012102f48b8ab9a082a1cf94dcd7052ddea7d260b40cf01e83aa3df00f2266721ef420024730440220527c3eb66a06d697a078b2b2bdf9be52f9fe036b1e3422a0a150e151ff0cd25b0220268688d8d9a3dd24b9f846b1b2f1b1f1ed84443f0023e26fa1ac5f2c1f0626ac012103acc2fbe36c425eb49389e5896232ef90beda75531845cd726dfed5f60a1fedd10247304402202eee600a307d10fc4777e8143d3db8994a6e742d56d4e3ce67a21a1e5e509178022022ee1b1fee5d7ec8112a56b1c0ab2eef1be00907d384bbf10a7a9d2d27564fb5012103bd6876311fbf657af0c1c85e907c3adf8d5086d1b3cf2cd4805b40873d2cf3cd02473044022042dbc6204b70da1548456beef504d5e8d61349dd36913832060b35f61a360429022006940b48cff72f6476b8d4495126618766500f0868fb99ba40ab518934e9cc2b0121035aa46c0cf9b30a9edf20c65e5c39158aefbfdd2b7a049d146f42b7dc3163d1b50247304402207811bd5b127e8a693f20115f7f8b8b4dec6a4d5df32109b21e1252331778ac5202202ac727cc6c53287110fcd371845b5fcdba825cb9e60992cc01cffa8e2ee41701012102700455a96ddb63fdaf8fc3ad60d02b057f8e00ed512476d817150a22fd4495d90247304402202caf8f9c584fe1b5214dc2a67f42fe3b9fd7386b98807fc6bc273a2cf519769902201f9f7b407f92c7df84701e4259acb198ca19c5edbd860385caa6ca1316417c010121035bfcbb577fe3a3a805c78226c7e7c573053e85e6641243c8f435acde0e04668902473044022074d6273ed2c7f338c9db6a979f64f572a21e5a324eec4979dad77383b25263de02202635d0e21ddf4e46f5751d4d6117ad559f04b7a6d3d00f13dd784b82a902638e012103de05dcec6736d4e15dd88c5b34b638fee6cccfd8b260d53379a43be0b343617cd9540c00

---

# EPIC: Bitcoin Transaction Relay over LoRa Meshtastic

**Goal:** To enable users to broadcast Bitcoin raw transactions by sending them as **chunked hexadecimal strings** via a LoRa Meshtastic direct message, using a dedicated client script (`btcmesh-cli.py`). The relay device (`btcmesh-server.py`) will reassemble these chunks, decode, validate, and then relay the complete transaction to a configured Bitcoin RPC node.

**User Persona:** A Bitcoin user who wants to broadcast a raw transaction using a command-line tool (`btcmesh-cli.py`), potentially in an environment with limited or censored internet access, but with LoRa Meshtastic network availability.

---

## Stories:

### 1. Meshtastic Communication (Relay Device - `btcmesh-server.py`)

- [x] **Story 1.1: Initialize Meshtastic Interface (Relay Device - `btcmesh-server.py`)**
- [x] *   **As a** system operator,
- [x] *   **I want** the relay application (`btcmesh-server.py`) to initialize a connection to its Meshtastic device,
- [x] *   **So that** it can send and receive messages.
    - [x] *   **Scenario:** Application starts
        - [x] *   **Given** a Meshtastic device is connected (e.g., via serial, configurable via `.env` or auto-detect).
        - [x] *   **When** the relay application (`btcmesh-server.py`) starts.
        - [x] *   **Then** it successfully establishes a connection with the Meshtastic interface.
        - [x] *   **And** logs the successful initialization.
    *   _Note: Serial port is configurable via `MESHTASTIC_SERIAL_PORT` in `.env` file. Implemented `core/config_loader.py`._

- [x] **Story 1.2: Server requests and receives chunk 1 from client, ACKs, and requests next chunk**
    - [x] *   **As a** server,
    - [x] *   **I want** to request chunk 1 after session initialization, receive it, ACK it, and request chunk 2,
    - [x] *   **So that** the client only sends the next chunk after the previous is received and processed.
        - [x] *   **Given** a session is initialized and the server has requested chunk 1,
        - [x] *   **When** the client sends `BTC_CHUNK|<session_id>|1/<total_chunks>|<hex_payload>`,
        - [x] *   **Then** the server responds with `BTC_CHUNK_ACK|<session_id>|1|OK|REQUEST_CHUNK|2` and is ready for the next chunk.

- [ ] **Story 1.3: Timeout and Retries**
    - [ ] *   **As a** client or server,
    - [ ] *   **I want** to retry a message up to 3 times if no response is received within 30 seconds,
    - [ ] *   **So that** transient losses do not cause session failure.
        - [ ] *   **Given** a message is sent and not acknowledged within 30 seconds,
        - [ ] *   **When** the sender retries up to 3 times,
        - [ ] *   **Then** the session continues if a response is received, or aborts after 3 failures.

- [ ] **Story 1.4: Session Abort**
    - [ ] *   **As a** client or server,
    - [ ] *   **I want** to abort a session with a reason,
    - [ ] *   **So that** both sides can clean up and notify the user of failure.
        - [ ] *   **Given** a session is active,
        - [ ] *   **When** either side sends `BTC_SESSION_ABORT|<session_id>|<reason>`,
        - [ ] *   **Then** the other side stops processing and logs the abort.

- [ ] **Story 1.5: Multiple Concurrent Sessions**
    - [ ] *   **As a** server,
    - [ ] *   **I want** to handle multiple concurrent sessions from different clients,
    - [ ] *   **So that** multiple users can upload transactions in parallel.
        - [ ] *   **Given** multiple clients initiate sessions with unique IDs,
        - [ ] *   **When** the server receives messages,
        - [ ] *   **Then** it tracks and processes each session independently.

- [ ] **Story 1.6: Chunk Size and Payload Limit**
    - [ ] *   **As a** client,
    - [ ] *   **I want** to use a fixed chunk size of 170 bytes (hex payload),
    - [ ] *   **So that** each message fits within the Meshtastic payload size limit.
        - [ ] *   **Given** a transaction to send,
        - [ ] *   **When** the client splits it into chunks,
        - [ ] *   **Then** each chunk (including header) does not exceed the Meshtastic payload limit.

- [ ] **Story 1.7: ACK/NACK and Error Handling**
    - [ ] *   **As a** server,
    - [ ] *   **I want** to ACK each valid chunk and NACK invalid or duplicate chunks,
    - [ ] *   **So that** the client can retry or abort as needed.
        - [ ] *   **Given** a chunk is received,
        - [ ] *   **When** it is valid and in order,
        - [ ] *   **Then** the server sends `BTC_CHUNK_ACK|<session_id>|<chunk_number>|OK`.
        - [ ] *   **When** it is invalid or out of order,
        - [ ] *   **Then** the server sends `BTC_CHUNK_NACK|<session_id>|<chunk_number>|ERROR|<reason>`.

- [ ] **Story 1.8: End-to-End Test (TDD/BDD)**
    - [ ] *   **As a** developer,
    - [ ] *   **I want** to verify the full protocol with simulated packet loss and reordering,
    - [ ] *   **So that** the implementation is robust and reliable.
        - [ ] *   **Given** a simulated lossy channel,
        - [ ] *   **When** a client sends a transaction using the protocol,
        - [ ] *   **Then** the server receives and reassembles the transaction correctly, or aborts with a clear error.

### 2. Transaction Payload Handling (Relay Device - `btcmesh-server.py`)

- [x] **Story 2.1: Reassemble Chunked Transaction Hex**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to reassemble the complete raw Bitcoin transaction hex string from incoming chunks,
    - [x] *   **So that** it can be decoded and validated.
        - [x] *   **Scenario:** Receiving all chunks for a transaction in order
        - [x] *   **Scenario:** Receiving chunks out of order
        - [x] *   **Scenario:** Timeout waiting for missing chunks
        - [x] *   **Scenario:** Receiving a duplicate chunk
        - [x] *   **Scenario:** Mismatched `total_chunks` for the same `tx_session_id`
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestTransactionReassemblerStory21`)._

- [x] **Story 2.2: Validate Reassembled Hexadecimal String**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to validate that the reassembled payload is a valid hexadecimal string,
    - [x] *   **So that** I don't try to decode invalid data.
        - [x] *   **Scenario:** Reassembled payload is valid hex
        - [x] *   **Scenario:** Reassembled payload contains non-hex characters
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestHexValidationStory22`)._

- [x] **Story 2.3: Decode Reassembled Raw Bitcoin Transaction Hex**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to decode the reassembled and validated hexadecimal string into its constituent Bitcoin transaction fields,
    - [x] *   **So that** basic structural validation can be performed.
        - [x] *   **Scenario:** Valid reassembled hex string representing a simple P2PKH transaction
        - [x] *   **Scenario:** Malformed or incomplete reassembled hex string
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestTransactionDecodeStory23`)._

### 3. Basic Transaction Validation (Relay Device - `btcmesh-server.py`)

- [x] **Story 3.1: Perform Basic Sanity Checks on Decoded Transaction**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to perform basic sanity checks on the decoded transaction structure (from reassembled data),
    - [x] *   **So that** obviously invalid transactions are not relayed.
        - [x] *   **Scenario:** Decoded transaction with no inputs
        - [x] *   **Scenario:** Decoded transaction with no outputs
        - [x] *   **Scenario:** Decoded transaction with valid structure
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestTransactionSanityChecksStory31`)._

### 4. Bitcoin RPC Communication (Relay Device - `btcmesh-server.py`)
    (Stories 4.1, 4.2, 4.3 remain largely the same but operate on data validated from reassembled chunks)

- [x] **Story 4.1: Configure Bitcoin RPC Connection Details**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to load Bitcoin Core RPC connection details from .env,
    - [x] *   **So that** the relay can connect to the Bitcoin node securely and flexibly.
        - [x] *   **Scenario:** Config present in .env
        - [x] *   **Scenario:** Missing/partial config in .env
        - [x] *   **Scenario:** Invalid config in .env
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestBitcoinRpcConfigStory41`)._

- [x] **Story 4.2: Connect to Bitcoin RPC**
    - [x] *   **As a** relay system (`btcmesh-server.py`),
    - [x] *   **I want** to connect to the Bitcoin Core node's RPC interface using the loaded config,
    - [x] *   **So that** I can prepare to broadcast transactions.
        - [x] *   **Scenario:** Valid config, node reachable
        - [x] *   **Scenario:** Invalid config or node unreachable
    *   _Note: All scenarios are now covered by tests in `tests/test_btcmesh_server.py` (see `TestBitcoinRpcConnectionStory42`)._

- [x] **Story 4.3: Broadcast Transaction via RPC `sendrawtransaction`** (Input is the reassembled, validated hex)
    - [x] Server now broadcasts transactions via Bitcoin Core RPC after successful reassembly and validation.
    - [x] Sends ACK with TXID on success, NACK with error message on failure, to the original sender.

### 5. Logging and Configuration (Relay Device - `btcmesh-server.py`)
    (Stories 5.1, 5.2 remain largely the same)

- [x] **Story 5.1: Implement Local Logging** (Ensure logging covers chunking/reassembly)
- [x] **Story 5.2: Manage Configuration File** (May need a parameter for reassembly timeout)
    - [x] Server loads reassembly timeout from config (.env or environment).
    - [x] Logs the loaded value and its source (env/default) at startup.
    - [x] TransactionReassembler is initialized with the configured timeout.
    - [x] All logging/config stories for the relay are now complete.

### 6. `btcmesh-cli.py` Client Sender Script

- [x] **Story 6.1: Parse Command-Line Arguments (`btcmesh-cli.py`)**
    - [x] btcmesh-cli.py parses -d/--destination and -tx/--tx arguments.
    - [x] Validates raw tx hex (even length, hex chars).
    - [x] Handles missing/invalid input with usage or error message.
    - [x] Supports --dry-run for testable output.
    - [x] Ready for chunking/sending logic (Story 6.3).

- [x] **Story 6.2: Initialize Meshtastic Interface (`btcmesh-cli.py`)**
    - [x] CLI initializes Meshtastic interface (auto-detect or config port).
    - [x] Logs all connection attempts and errors to stdout and CLI log file.
    - [x] Handles device not found, import error, and exits with clear message.
    - [x] All TDD/BDD scenarios covered by tests and implementation.

- [x] **Story 6.3: Chunk Transaction and Send via Meshtastic (`btcmesh-cli.py`)**
    - [x] CLI segments, formats, and sends all transaction chunks via Meshtastic.
    - [x] Prints and logs confirmation for each chunk and final message.
    - [x] Handles and logs errors on sendText failure, aborts as needed.
    - [x] All TDD/BDD scenarios for multi-chunk, single-chunk, error, and logging are covered and passing.

- [x] **Story 6.4: Listen for Acknowledgement (`btcmesh-cli.py`) (Optional Enhancement)**
- [x] *   **As a** user of `btcmesh-cli.py`,
- [x] *   **I want** the script to listen for a confirmation message from the relay,
- [x] *   **So that** I know if the transaction was successfully processed or if an error occurred.
    - [x] *   **Scenario:** Relay sends SUCCESS acknowledgement
        - [x] *   **Given** `btcmesh-cli.py` has sent all chunks for `tx_session_id`.
        - [x] *   **When** a message "BTC_ACK|<tx_session_id>|SUCCESS|TXID:[actual_txid]" is received from the relay.
        - [x] *   **Then** `btcmesh-cli.py` prints "Transaction successfully broadcast by relay. TXID: [actual_txid]" and exits.
    - [x] *   **Scenario:** Relay sends ERROR acknowledgement
        - [x] *   **Given** `btcmesh-cli.py` has sent all chunks for `tx_session_id`.
        - [x] *   **When** a message "BTC_NACK|<tx_session_id>|ERROR|[error_details]" is received from the relay.
        - [x] *   **Then** `btcmesh-cli.py` prints "Relay reported an error: [error_details]" and exits.
    - [x] *   **Scenario:** Timeout waiting for acknowledgement
        - [x] *   **Given** `btcmesh-cli.py` has sent all chunks.
        - [x] *   **And** no BTC_ACK/BTC_NACK is received within a timeout period (e.g., 2 minutes).
        - [x] *   **When** the timeout occurs.
        - [x] *   **Then** `btcmesh-cli.py` prints "No acknowledgement received from relay for session <tx_session_id>" and exits.

### 7. End-to-End Flow (With Chunking)

- [x] **Story 7.1: Successful End-to-End Transaction Relay (Chunked)**
- [x] *   **As a** user,
- [x] *   **I want** to use `btcmesh-cli.py` to send a valid raw Bitcoin transaction hex,
- [x] *   **So that** it gets chunked, sent, reassembled by the relay, broadcasted to the Bitcoin network, and I receive a confirmation with the TXID via `btcmesh-cli.py`.
    - [x] *   **Scenario:** User runs `btcmesh-cli.py` with a valid raw tx
        - [x] *   **Given** the relay device (`btcmesh-server.py`) is running and configured correctly.
        - [x] *   **And** the user has `btcmesh-cli.py` and a valid raw Bitcoin transaction hex.
        - [x] *   **When** the user executes `btcmesh-cli.py -d <relay_node_id> -tx <raw_tx_hex>`.
        - [x] *   **Then** `btcmesh-cli.py` connects to its Meshtastic device.
        - [x] *   **And** generates a `tx_session_id`.
        - [x] *   **And** chunks the transaction hex and sends each chunk (e.g., `BTC_TX|sess123|1/2|...`, `BTC_TX|sess123|2/2|...`) to the relay.
        - [x] *   **And** the relay device (`btcmesh-server.py`) receives these chunks.
        - [x] *   **And** the relay reassembles the complete hex string for `sess123` successfully.
        - [x] *   **And** the relay decodes the hex string successfully.
        - [x] *   **And** the relay validates the transaction structure successfully.
        - [x] *   **And** the relay connects to the Bitcoin RPC node.
        - [x] *   **And** the relay broadcasts the transaction successfully using `sendrawtransaction`.
        - [x] *   **And** the relay receives a TXID from the RPC node.
        - [x] *   **And** the relay sends a DM "BTC_ACK|sess123|SUCCESS|TXID:[actual_txid]" back to the `btcmesh-cli.py` sender's node ID.
        - [x] *   **And** (if Story 6.4 implemented) `btcmesh-cli.py` receives this ACK and prints the success message with TXID.
        - [x] *   **And** all relevant steps are logged by both `btcmesh-cli.py` and the relay device (`btcmesh-server.py`)

---

# EPIC: Reliable Chunked Transaction Relay Protocol for LoRa/Meshtastic

**Goal:**
Ensure reliable, in-order, lossless transmission of large Bitcoin transactions over unreliable LoRa/Meshtastic links using a stop-and-wait ARQ protocol.

---

## Stories:

### 1. Reliable Session-Based Chunk Transfer

- [x] **Story 1.1: Session Initialization (Client/Server)**
    - [x] *   **As a** client,
    - [x] *   **I want** to initiate a session with a unique session ID, total chunk count, and chunk size,
    - [x] *   **So that** the server can prepare to receive a new transaction in chunks.
        - [x] *   **Given** the client has a transaction to send,
        - [x] *   **When** it sends `BTC_SESSION_START|<session_id>|<total_chunks>|<chunk_size>` to the server,
        - [x] *   **Then** the server responds with `BTC_SESSION_ACK|<session_id>|READY|REQUEST_CHUNK|1`.

- [x] **Story 1.2: Server requests and receives chunk 1 from client, ACKs, and requests next chunk**
    - [x] *   **As a** server,
    - [x] *   **I want** to request chunk 1 after session initialization, receive it, ACK it, and request chunk 2,
    - [x] *   **So that** the client only sends the next chunk after the previous is received and processed.
        - [x] *   **Given** a session is initialized and the server has requested chunk 1,
        - [x] *   **When** the client sends `BTC_CHUNK|<session_id>|1/<total_chunks>|<hex_payload>`,
        - [x] *   **Then** the server responds with `BTC_CHUNK_ACK|<session_id>|1|OK|REQUEST_CHUNK|2` and is ready for the next chunk.

- [ ] **Story 1.3: Timeout and Retries**
    - [ ] *   **As a** client or server,
    - [ ] *   **I want** to retry a message up to 3 times if no response is received within 30 seconds,
    - [ ] *   **So that** transient losses do not cause session failure.
        - [ ] *   **Given** a message is sent and not acknowledged within 30 seconds,
        - [ ] *   **When** the sender retries up to 3 times,
        - [ ] *   **Then** the session continues if a response is received, or aborts after 3 failures.

- [ ] **Story 1.4: Session Abort**
    - [ ] *   **As a** client or server,
    - [ ] *   **I want** to abort a session with a reason,
    - [ ] *   **So that** both sides can clean up and notify the user of failure.
        - [ ] *   **Given** a session is active,
        - [ ] *   **When** either side sends `BTC_SESSION_ABORT|<session_id>|<reason>`,
        - [ ] *   **Then** the other side stops processing and logs the abort.

- [ ] **Story 1.5: Multiple Concurrent Sessions**
    - [ ] *   **As a** server,
    - [ ] *   **I want** to handle multiple concurrent sessions from different clients,
    - [ ] *   **So that** multiple users can upload transactions in parallel.
        - [ ] *   **Given** multiple clients initiate sessions with unique IDs,
        - [ ] *   **When** the server receives messages,
        - [ ] *   **Then** it tracks and processes each session independently.

- [ ] **Story 1.6: Chunk Size and Payload Limit**
    - [ ] *   **As a** client,
    - [ ] *   **I want** to use a fixed chunk size of 170 bytes (hex payload),
    - [ ] *   **So that** each message fits within the Meshtastic payload size limit.
        - [ ] *   **Given** a transaction to send,
        - [ ] *   **When** the client splits it into chunks,
        - [ ] *   **Then** each chunk (including header) does not exceed the Meshtastic payload limit.

- [ ] **Story 1.7: ACK/NACK and Error Handling**
    - [ ] *   **As a** server,
    - [ ] *   **I want** to ACK each valid chunk and NACK invalid or duplicate chunks,
    - [ ] *   **So that** the client can retry or abort as needed.
        - [ ] *   **Given** a chunk is received,
        - [ ] *   **When** it is valid and in order,
        - [ ] *   **Then** the server sends `BTC_CHUNK_ACK|<session_id>|<chunk_number>|OK`.
        - [ ] *   **When** it is invalid or out of order,
        - [ ] *   **Then** the server sends `BTC_CHUNK_NACK|<session_id>|<chunk_number>|ERROR|<reason>`.

- [ ] **Story 1.8: End-to-End Test (TDD/BDD)**
    - [ ] *   **As a** developer,
    - [ ] *   **I want** to verify the full protocol with simulated packet loss and reordering,
    - [ ] *   **So that** the implementation is robust and reliable.
        - [ ] *   **Given** a simulated lossy channel,
        - [ ] *   **When** a client sends a transaction using the protocol,
        - [ ] *   **Then** the server receives and reassembles the transaction correctly, or aborts with a clear error.